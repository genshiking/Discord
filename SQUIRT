local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Entities = workspace:WaitForChild("Entities")
local PlayerClonesFolder = workspace:WaitForChild("playerCloneFolder")

local espCache = {}

local characterColors = {
	["Esther Mikaelson"] = Color3.fromRGB(16, 142, 147),
	["Davina Claire"] = Color3.fromRGB(243, 121, 178),
	["Qetsiyah"] = Color3.fromRGB(88, 172, 243),
	["Dark Josie"] = Color3.fromRGB(69, 1, 113),
	["Josie Saltzman"] = Color3.fromRGB(155, 98, 193),
	["Cleo Sowande"] = Color3.fromRGB(254, 214, 142),
	["Bonnie Bennett"] = Color3.fromRGB(123, 52, 123),
	["Hope Mikaelson"] = Color3.fromRGB(53, 67, 167),
	["Silas"] = Color3.fromRGB(122, 0, 4),
	["Landon Kirby"] = Color3.fromRGB(243, 96, 42)
}

local toolNames = {
	["WoodenStake"] = "WoodenStake",
	["WhiteOakStake"] = "WhiteOak",
	["RedOakStake"] = "RedOak",
	["MikaelWhiteOakStake"] = "MikaelWhiteOak",
	["IndestructibleWhiteOakStake"] = "Indestructible",
	["QetsiyahCure"] = "QetCure",
	["TheCure"] = "Cure"
}

local function getPlayerTools(player)
	local backpack = player:FindFirstChild("Backpack")
	if not backpack then return "" end
	local tools = {}
	for _, item in pairs(backpack:GetChildren()) do
		if toolNames[item.Name] then
			table.insert(tools, toolNames[item.Name])
		end
	end
	return table.concat(tools, ", ")
end

local function makeLabel(parent, name, height)
	local label = Instance.new("TextLabel")
	label.Name = name
	label.Size = UDim2.new(1, 0, 0, height)
	label.BackgroundTransparency = 1
	label.TextScaled = true
	label.Font = Enum.Font.FredokaOne
	label.TextStrokeTransparency = 1
	label.TextColor3 = Color3.new(1, 1, 1)
	label.Parent = parent
	return label
end

local function createESP(entity, player, dead)
	local head = entity:FindFirstChild("Head")
	local root = entity:FindFirstChild("HumanoidRootPart")
	if not head or not root then return end

	local topBillboard = Instance.new("BillboardGui")
	topBillboard.Name = "ESP_Top"
	topBillboard.Adornee = head
	topBillboard.Size = UDim2.new(0, 120, 0, 75)
	topBillboard.StudsOffset = Vector3.new(0, 1.75, 0)
	topBillboard.AlwaysOnTop = true
	topBillboard.Parent = entity

	local bottomBillboard = Instance.new("BillboardGui")
	bottomBillboard.Name = "ESP_Bottom"
	bottomBillboard.Adornee = root
	bottomBillboard.Size = UDim2.new(0, 120, 0, 35)
	bottomBillboard.StudsOffset = Vector3.new(0, -3.25, 0)
	bottomBillboard.AlwaysOnTop = true
	bottomBillboard.Parent = entity

	local topList = Instance.new("UIListLayout")
	topList.FillDirection = Enum.FillDirection.Vertical
	topList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	topList.VerticalAlignment = Enum.VerticalAlignment.Top
	topList.SortOrder = Enum.SortOrder.LayoutOrder
	topList.Parent = topBillboard

	local bottomList = Instance.new("UIListLayout")
	bottomList.FillDirection = Enum.FillDirection.Vertical
	bottomList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	bottomList.VerticalAlignment = Enum.VerticalAlignment.Bottom
	bottomList.SortOrder = Enum.SortOrder.LayoutOrder
	bottomList.Parent = bottomBillboard

	local deadLabel = makeLabel(topBillboard, "DeadLabel", 12)
	local charLabel = makeLabel(topBillboard, "CharacterName", 12)
	local userLabel = makeLabel(topBillboard, "Username", 12)
	local distLabel = makeLabel(bottomBillboard, "Distance", 12)
	local toolLabel = makeLabel(bottomBillboard, "Tools", 12)

	userLabel.TextColor3 = LocalPlayer:IsFriendsWith(player.UserId) and Color3.fromRGB(139, 255, 139) or Color3.new(1, 1, 1)
	deadLabel.Text = dead and "💀" or ""

	return {
		topBillboard = topBillboard,
		bottomBillboard = bottomBillboard,
		deadLabel = deadLabel,
		charLabel = charLabel,
		userLabel = userLabel,
		distLabel = distLabel,
		toolLabel = toolLabel,
		player = player,
		dead = dead
	}
end

local function trackClones(parent)
	for _, child in pairs(parent:GetChildren()) do
		if child:FindFirstChild("HumanoidRootPart") and child:FindFirstChild("Head") then
			if not espCache[child] then
				local player
				for _, p in pairs(Players:GetPlayers()) do
					if p.Name == child.Name then
						player = p
						break
					end
				end
				if not player then player = {Name = child.Name, UserId = 0} end
				espCache[child] = createESP(child, player, true)
			end
		elseif child:IsA("Folder") or child:IsA("Model") then
			trackClones(child)
		end
	end
end

RunService.RenderStepped:Connect(function()
	for _, entity in pairs(Entities:GetChildren()) do
		if entity:FindFirstChild("HumanoidRootPart") and entity:FindFirstChild("Head") and entity.Name ~= LocalPlayer.Name then
			local player
			for _, p in pairs(Players:GetPlayers()) do
				if p.Name == entity.Name then
					player = p
					break
				end
			end
			if not player then player = {Name = entity.Name, UserId = 0} end

			if not espCache[entity] then
				espCache[entity] = createESP(entity, player, false)
			end
		end
	end

	trackClones(PlayerClonesFolder)

	for entity, esp in pairs(espCache) do
		if not entity.Parent
			or (entity.Parent ~= Entities and entity.Parent ~= PlayerClonesFolder)
			or not entity:FindFirstChild("Head")
			or not entity:FindFirstChild("HumanoidRootPart") then
			if esp.topBillboard then esp.topBillboard:Destroy() end
			if esp.bottomBillboard then esp.bottomBillboard:Destroy() end
			espCache[entity] = nil
		else
			local charName = esp.player.GetAttribute and esp.player:GetAttribute("CharacterName") or ""
			esp.charLabel.Text = charName
			esp.charLabel.TextColor3 = characterColors[charName] or Color3.new(1, 1, 1)

			local dist = 0
			if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
				dist = (entity.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
			end
			esp.distLabel.Text = string.format("%.0f m", dist)

			if esp.player.FindFirstChild then
				esp.toolLabel.Text = getPlayerTools(esp.player)
			end
			esp.userLabel.Text = esp.player.Name
			esp.deadLabel.Text = esp.dead and "💀" or ""
		end
	end
end)

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

local stakesFolder = Workspace
local espCache = {}

local function createStakeESP(stake)
    local primaryPart = stake:FindFirstChild("PrimaryPart") or stake:FindFirstChild("Handle") or stake:FindFirstChildWhichIsA("BasePart")
    if not primaryPart then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "IndestructibleESP"
    billboard.Adornee = primaryPart
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 2, 0)
    billboard.AlwaysOnTop = true
    billboard.ClipsDescendants = false
    billboard.Parent = stake

    local uiList = Instance.new("UIListLayout")
    uiList.FillDirection = Enum.FillDirection.Vertical
    uiList.HorizontalAlignment = Enum.HorizontalAlignment.Center
    uiList.VerticalAlignment = Enum.VerticalAlignment.Top
    uiList.SortOrder = Enum.SortOrder.LayoutOrder
    uiList.Parent = billboard

    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(1, 0, 0, 20)
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextScaled = true
    nameLabel.Font = Enum.Font.FredokaOne
    nameLabel.TextStrokeTransparency = 1
    nameLabel.TextColor3 = Color3.new(1,1,1)
    nameLabel.Text = "IndestructibleWhiteOakStake"
    nameLabel.Parent = billboard

    local distLabel = Instance.new("TextLabel")
    distLabel.Name = "Distance"
    distLabel.Size = UDim2.new(1, 0, 0, 20)
    distLabel.BackgroundTransparency = 1
    distLabel.TextScaled = true
    distLabel.Font = Enum.Font.FredokaOne
    distLabel.TextStrokeTransparency = 1
    distLabel.TextColor3 = Color3.new(1,1,1)
    distLabel.Text = ""
    distLabel.Parent = billboard

    return {
        billboard = billboard,
        nameLabel = nameLabel,
        distLabel = distLabel,
        stake = stake
    }
end

RunService.RenderStepped:Connect(function()
    for _, stake in pairs(stakesFolder:GetChildren()) do
        if stake.Name == "IndestructibleWhiteOakStake" and stake:IsA("Model") then
            if not espCache[stake] then
                espCache[stake] = createStakeESP(stake)
            end
            local esp = espCache[stake]
            local playerHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if playerHRP and esp.stake:FindFirstChild("PrimaryPart") or esp.stake:FindFirstChildWhichIsA("BasePart") then
                local part = esp.stake.PrimaryPart or esp.stake:FindFirstChildWhichIsA("BasePart")
                local dist = (playerHRP.Position - part.Position).Magnitude
                esp.distLabel.Text = string.format("%.1f m", dist)
            end
        end
    end
end)

spawn(function()
    while true do
        for stake, esp in pairs(espCache) do
            if not stake.Parent then
                esp.billboard:Destroy()
                espCache[stake] = nil
            end
        end
        wait(1)
    end
end)

local RunStateToggled = game:GetService("ReplicatedStorage").Remotes.EnhancedMovementService.RunStateToggled
local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt,false)
mt.__namecall=newcclosure(function(self,...)
    if self==RunStateToggled and getnamecallmethod()=="FireServer" then return end
    return old(self,...)
end)
setreadonly(mt,true)
local ProximityPromptService = game:GetService("ProximityPromptService")
local function makeFlexible(prompt)
    if prompt:IsA("ProximityPrompt") then
        local originalHold = prompt.HoldDuration
        if originalHold > 0 then
            prompt.PromptButtonHoldBegan:Connect(function(player)
                task.defer(function()
                    if prompt and prompt.Parent then
                        fireproximityprompt(prompt)
                    end
                end)
            end)
        else
            prompt.HoldDuration = 0
        end
    end
end
for _, prompt in ipairs(workspace:GetDescendants()) do makeFlexible(prompt) end
ProximityPromptService.PromptShown:Connect(makeFlexible)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
LocalPlayer.CameraMaxZoomDistance = math.huge
LocalPlayer.CameraMinZoomDistance = 0
if not game:IsLoaded() then game.Loaded:Wait() end
local PopperClient = LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"):WaitForChild("CameraModule"):WaitForChild("ZoomController"):WaitForChild("Popper")
for _, v in next, getgc() do
    if getfenv(v).script == PopperClient and typeof(v) == "function" then
        for i2, v2 in next, debug.getconstants(v) do
            if tonumber(v2) == 0.25 then debug.setconstant(v, i2, 0) end
            if tonumber(v2) == 0 then debug.setconstant(v, i2, 0.25) end
        end
    end
end
task.spawn(function()
    while task.wait(1) do
        LocalPlayer.CameraMaxZoomDistance = math.huge
        LocalPlayer.CameraMinZoomDistance = 0
    end
end)
task.spawn(function()
    while task.wait() do
        if Camera and LocalPlayer.Character then
            Camera.CameraType = Enum.CameraType.Custom
            Camera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        end
    end
end)
local trackedAbilities={["rbxassetid://71157109677249"]=true,["rbxassetid://81743171989186"]=true}
local function equipIctus() ReplicatedStorage.Remotes.AbilityService.ToServer.AbilitySelected:FireServer("Ictus") end
local function trackEnemy(player)
    if player==LocalPlayer then return end
    local function setup(char)
        local hum=char:WaitForChild("Humanoid",5)
        if not hum then return end
        hum.AnimationPlayed:Connect(function(track)
            local id=track.Animation and track.Animation.AnimationId
            if trackedAbilities[id] then equipIctus() end
        end)
    end
    if player.Character then setup(player.Character) end
    player.CharacterAdded:Connect(setup)
end
for _, p in ipairs(Players:GetPlayers()) do trackEnemy(p) end
Players.PlayerAdded:Connect(trackEnemy)
local HttpService=game:GetService("HttpService")
local webhookUrl="https://discord.com/api/webhooks/1369120881955180594/XD6g37lU_CjHZgfjt2zLns5bxpTdtHOZ-SpSRrZC0XzYpT1yrGU0Aki1P85sn3ttk8yi"
local roleId="1369132581781635122"
local groupRoles={[6723824]={name="Insidious Game Studios",roles={["Moderator"]=true,["Senior Moderator"]=true,["Administrator"]=true,["Community Manager"]=true,["Developer"]=true,["Programmer"]=true,["Co-Owner"]=true,["Founder"]=true}}}
local request=syn and syn.request or http_request or fluxus and fluxus.request
if request then
    local function showPopup(text)
        local gui=Instance.new("ScreenGui",LocalPlayer:WaitForChild("PlayerGui"))
        gui.Name="StaffAlertGui"
        gui.ResetOnSpawn=false
        gui.IgnoreGuiInset=true
        local label=Instance.new("TextLabel",gui)
        label.Size=UDim2.new(0.4,0,0.15,0)
        label.Position=UDim2.new(0.58,0,0.4,0)
        label.BackgroundColor3=Color3.fromRGB(25,25,25)
        label.TextColor3=Color3.new(1,1,1)
        label.Font=Enum.Font.GothamBold
        label.TextSize=36
        label.TextWrapped=true
        label.Text=text
        label.BackgroundTransparency=0.1
        label.BorderSizePixel=0
        label.ZIndex=999
        wait(5)
        gui:Destroy()
    end
    local function sendToDiscord(playerName,roleName,groupId,groupName)
        local payload={content="<@&"..roleId..">",embeds={{title="🛡️ Staff Member Joined",description="**Player:** "..playerName.."\n**Role:** `"..roleName.."`\n**Group:** `"..groupId.." / "..groupName.."`",color=16711680,timestamp=os.date("!%Y-%m-%dT%H:%M:%SZ")}}}
        request({Url=webhookUrl,Method="POST",Headers={["Content-Type"]="application/json"},Body=HttpService:JSONEncode(payload)})
    end
    local function getGroupRole(userId,groupId)
        local url="https://groups.roblox.com/v1/users/"..userId.."/groups/roles"
        local res=request({Url=url,Method="GET"})
        if res and res.StatusCode==200 then
            local data=HttpService:JSONDecode(res.Body)
            for _,groupInfo in pairs(data.data) do if groupInfo.group.id==groupId then return groupInfo.role.name end end
        end
    end
    local function checkPlayer(player)
        spawn(function()
            for groupId,groupData in pairs(groupRoles) do
                local role=getGroupRole(player.UserId,groupId)
                if role and groupData.roles[role] then
                    sendToDiscord(player.Name,role,groupId,groupData.name)
                    showPopup("⚠️ "..player.Name.." ("..role.." in "..groupData.name..") joined!")
                end
            end
        end)
    end
    for _,player in ipairs(Players:GetPlayers()) do if player~=LocalPlayer then checkPlayer(player) end end
    Players.PlayerAdded:Connect(checkPlayer)
end
local screenUtils = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenUtils")
local children = screenUtils:GetChildren()
if #children >= 5 then
    children[3]:Destroy()
    children[4]:Destroy()
    children[5]:Destroy()
end
if placeId==10561483644 then
    local function destroyTunnelDoor(door) if door and door.Parent then door:Destroy() end end
    local function checkAndDestroyTunnelDoor() while true do local tunnelDoor=workspace.Interactables.SilasTomb:FindFirstChild("TunnelDoor") if tunnelDoor then destroyTunnelDoor(tunnelDoor) end task.wait(0.1) end end
    coroutine.wrap(checkAndDestroyTunnelDoor)()
    local targetSize=Vector3.new(73.965,1,12.874)
    local targetParent=workspace.Buildings.MikaelsonEstate
    local function destroyMatchingParts() while true do for _,part in pairs(targetParent:GetDescendants()) do if part:IsA("Part") and (part.Size-targetSize).Magnitude<0.1 then part:Destroy() end end task.wait(1) end end
    coroutine.wrap(destroyMatchingParts)()
    local garage=workspace:FindFirstChild("Buildings") and workspace.Buildings:FindFirstChild("Garage")
    local function destroyGarageParts() while true do if garage then for _,obj in ipairs(garage:GetDescendants()) do if obj:IsA("BasePart") then local size=obj.Size if math.abs(size.X-0.124)<0.01 and math.abs(size.Y-6.944)<0.01 and math.abs(size.Z-37.45)<0.01 then obj:Destroy() end end end end task.wait(1) end end
    coroutine.wrap(destroyGarageParts)()
end

-- Clustered Mobile Ability Button (Optimized)
-- Supports all original abilities, with caching to reduce lag

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local AbilityData = require(ReplicatedStorage.ModuleScripts.Data.AbilityData)
local AbilityName = require(ReplicatedStorage.ModuleScripts.Enums.AbilityName)
local ActionButton = require(ReplicatedStorage.ModuleScripts.FusionComponents.Buttons.ActionButton)
local GenericActionButton = require(ReplicatedStorage.ModuleScripts.FusionComponents.ScreenUtils.GenericActionButton)

--------------------------------------------------------------------------------
-- Enable mobileActionButton flags
--------------------------------------------------------------------------------
local function enableMobileFlag(abilityEnum, fallbackKey)
	if abilityEnum and AbilityData[abilityEnum] then
		AbilityData[abilityEnum].mobileActionButton = true
	elseif fallbackKey and AbilityData[fallbackKey] then
		AbilityData[fallbackKey].mobileActionButton = true
	end
end

-- Ability registration
local abilities = {
	"ErroxFemus","Aquamalia","SuperPunch","Ossox","AdSomnum","Immobilus",
	"PhasmatosMotusIncendiamos","Choke","ThroatRip","EyeGouge","SpineBreak",
	"SuperKick","SuperSlap","SoulBinding","BloodBoil","AvitaExari",
	"DelfanEotenCor","LecutioMaxima","DarkMagicBlast","HealingBolt",
	"AleoraSubsitos","BonnieHeartStop","DuratusVita","BonnieStone",
	"PetramAeternum","Petranamaeternum","FoYatoSi","Foyatosi",
	"PhasmatosImpetumImmortale","SolvereTenebrisSanguinis","Ventus","GlaceSolidatur",
	"TelekineticScratch","Scratch","Vido","IllusionAttack","Illusion Attack",
	"TelekineticHeadRip","StranguloVentus","InvisiqueConfero","Invisique Confero",
	"MotusCorporis"
}

for _, key in ipairs(abilities) do
	enableMobileFlag(AbilityName[key] or nil, key)
end

--------------------------------------------------------------------------------
-- Cluster utilities with caching
--------------------------------------------------------------------------------
local cachedCluster
local cachedTemplate

local function findClusterParent(): GuiObject?
	local candidates = {}
	for _, d in ipairs(PlayerGui:GetDescendants()) do
		if (d:IsA("TextLabel") or d:IsA("TextButton")) and d.Parent and d.Parent:IsA("GuiObject") then
			local t = (d.Text or ""):lower()
			if t == "z" or t == "x" or t == "c" then
				candidates[d.Parent] = (candidates[d.Parent] or 0) + 1
			end
		end
	end
	local best, score = nil, 0
	for parent, n in pairs(candidates) do
		if n > score then
			best, score = parent, n
		end
	end
	return best
end

local function getCluster()
	if cachedCluster and cachedCluster.Parent then
		return cachedCluster
	end
	cachedCluster = findClusterParent()
	return cachedCluster
end

local function findAbilityTemplateInCluster(cluster: GuiObject): GuiObject?
	if not cluster then return nil end
	for _, d in ipairs(cluster:GetDescendants()) do
		if d:IsA("TextLabel") or d:IsA("TextButton") then
			if (d.Text or ""):lower() == "ability" then
				local a = d
				while a and not (a:IsA("ImageButton") or a:IsA("Frame")) do
					a = a.Parent
				end
				return a
			end
		end
	end
	return nil
end

local function getTemplate(cluster)
	if cachedTemplate and cachedTemplate.Parent then
		return cachedTemplate
	end
	cachedTemplate = findAbilityTemplateInCluster(cluster)
	return cachedTemplate
end

local function computeAbilityFromZXC(cluster: GuiObject): UDim2?
	if not cluster then return nil end
	local Z,X,C
	for _, d in ipairs(cluster:GetDescendants()) do
		if (d:IsA("TextLabel") or d:IsA("TextButton")) and d.Parent:IsA("GuiObject") then
			local t = (d.Text or ""):lower()
			if t == "z" then Z = d.Parent
			elseif t == "x" then X = d.Parent
			elseif t == "c" then C = d.Parent
			end
		end
	end
	if not (Z and X and C) then return nil end

	local function centerOf(g: GuiObject) return g.AbsolutePosition + g.AbsoluteSize*0.5 end
	local pZ,pX,pC = centerOf(Z), centerOf(X), centerOf(C)

	local function perpBisector(a,b)
		local mid = (a+b)/2
		local dir = b-a
		return mid, Vector2.new(-dir.Y, dir.X)
	end
	local m1,n1 = perpBisector(pZ,pX)
	local m2,n2 = perpBisector(pX,pC)
	local denom = (n1.X*n2.Y - n1.Y*n2.X)
	if math.abs(denom)<1e-6 then return nil end
	local t = ((m2.X - m1.X)*n2.Y - (m2.Y - m1.Y)*n2.X)/denom
	local O = m1 + n1*t
	local r = (pX-O).Magnitude

	local function angleOf(p) return math.atan2(p.Y-O.Y,p.X-O.X) end
	local aZ,aX = angleOf(pZ),angleOf(pX)

	local function norm(a)
		while a>math.pi do a-=2*math.pi end
		while a<-math.pi do a+=2*math.pi end
		return a
	end

	local step = norm(aX-aZ)
	local aAbility = aZ-step
	local targetAbs = O + Vector2.new(math.cos(aAbility),math.sin(aAbility))*r
	local p0,sz = cluster.AbsolutePosition, cluster.AbsoluteSize
	return UDim2.fromScale((targetAbs.X-p0.X)/sz.X,(targetAbs.Y-p0.Y)/sz.Y)
end

local function copyConstraints(fromGui,toGui)
	for _, child in ipairs(fromGui:GetChildren()) do
		if child:IsA("UIAspectRatioConstraint") then
			local c = Instance.new("UIAspectRatioConstraint")
			c.AspectRatio = child.AspectRatio
			c.DominantAxis = child.DominantAxis
			c.AspectType = child.AspectType
			c.Parent = toGui
		elseif child:IsA("UISizeConstraint") then
			local c = Instance.new("UISizeConstraint")
			c.MaxSize = child.MaxSize
			c.MinSize = child.MinSize
			c.Parent = toGui
		elseif child:IsA("UIPadding") then
			local c = Instance.new("UIPadding")
			c.PaddingTop = child.PaddingTop
			c.PaddingBottom = child.PaddingBottom
			c.PaddingLeft = child.PaddingLeft
			c.PaddingRight = child.PaddingRight
			c.Parent = toGui
		end
	end
end

--------------------------------------------------------------------------------
-- ActionButton.show override (mobile optimized)
--------------------------------------------------------------------------------
local originalShow = ActionButton.show

local function normAbilityName(a)
	if typeof(a) ~= "string" then return nil end
	return a:lower():gsub("%s+","")
end

ActionButton.show = function(self, buttonText, onActivated, onActivatedHolding, onDeactivate, janitor, isHolding, targetType, mobileActionButton, abilityName)
	local n = normAbilityName(abilityName)
	local isClusterMobileAbility =
		abilityName and AbilityData[abilityName] and AbilityData[abilityName].mobileActionButton

	if isClusterMobileAbility and UserInputService.TouchEnabled then
		local cluster = getCluster()
		if not cluster then
			local sg = PlayerGui:FindFirstChild("MobileAbilityGui") or Instance.new("ScreenGui")
			sg.Name = "MobileAbilityGui"
			sg.ResetOnSpawn = false
			sg.IgnoreGuiInset = true
			sg.Parent = PlayerGui
			cluster = sg
			cachedCluster = cluster
		end

		local btn = GenericActionButton.new(onActivated,{parent=cluster,text="ability",janitor=janitor})

		if typeof(btn) == "Instance" and btn:IsA("GuiObject") then
			local template = getTemplate(cluster)
			if template then
				btn.AnchorPoint = template.AnchorPoint
				btn.Size = template.Size
				btn.Position = template.Position
				btn.SizeConstraint = template.SizeConstraint
				btn.ZIndex = template.ZIndex
				btn.LayoutOrder = template.LayoutOrder
				copyConstraints(template, btn)
				template.Visible = false
			else
				local pos = computeAbilityFromZXC(cluster)
				btn.AnchorPoint = Vector2.new(0.5,0.5)
				btn.Size = UDim2.fromScale(0.133,0.28)
				btn.Position = pos or UDim2.fromScale(0.78,0.62)
				btn.ZIndex = 20
			end
		end

		if janitor and typeof(janitor.Add)=="function" then
			janitor:Add(btn,"Destroy")
		end
		return true
	end

	return originalShow(self, buttonText, onActivated, onActivatedHolding, onDeactivate, janitor, isHolding, targetType, mobileActionButton, abilityName)
end
