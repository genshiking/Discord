local placeId = game.PlaceId
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local maxDistance = 1000
_G.Settings = _G.Settings or { ShowNames = true, ShowDistance = true }
local toolNames = {
    RedOakStake = "RedOak",
    WhiteOakStake = "WhiteOak",
    QetsiyahCure = "QetCure",
    TheCure = "Cure",
    IndestructibleWhiteOakStake = "Indestructible"
}
local function createBox(color)
    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Transparency = 1
    box.Filled = false
    box.Color = color
    return box
end
local function createText(size,color)
    local text = Drawing.new("Text")
    text.Size = size
    text.Center = true
    text.Outline = true
    text.Color = color
    text.Visible = false
    return text
end
local espElements = {}
local function isTeammate(player)
    return LocalPlayer.Team and player.Team == LocalPlayer.Team
end
local function getBackpackTools(player)
    local backpack = player:FindFirstChildOfClass("Backpack")
    if not backpack then return nil end
    local foundTools = {}
    local addedTools = {}
    for _, tool in ipairs(backpack:GetChildren()) do
        local mappedName = toolNames[tool.Name]
        if mappedName and not addedTools[mappedName] then
            addedTools[mappedName] = true
            table.insert(foundTools, mappedName)
        end
    end
    return #foundTools>0 and table.concat(foundTools,", ") or nil
end
local function convertStudsToMeters(studs)
    return studs*0.28
end
local function removeESP(obj)
    if espElements[obj] then
        local e = espElements[obj]
        for _, v in pairs(e) do
            if v and v.Remove then v:Remove() end
        end
        espElements[obj] = nil
    end
end
local function updateESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player~=LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health>0 and not isTeammate(player) then
                local distance = convertStudsToMeters((LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude)
                local screenPos,onScreen = Camera:WorldToViewportPoint(rootPart.Position)
                if distance<maxDistance and onScreen then
                    local size = Vector2.new(1000/screenPos.Z,2000/screenPos.Z)
                    local pos = Vector2.new(screenPos.X-size.X/2,screenPos.Y-size.Y/2)
                    if not espElements[player] then
                        espElements[player] = {
                            box=createBox(Color3.fromRGB(0,0,255)),
                            charName=createText(14,Color3.fromRGB(150,150,150)),
                            name=createText(14,Color3.fromRGB(255,255,255)),
                            distance=createText(12,Color3.fromRGB(255,255,255)),
                            tools=createText(12,Color3.fromRGB(150,150,150))
                        }
                        player.AncestryChanged:Connect(function(_,parent) if not parent then removeESP(player) end end)
                        humanoid.Died:Connect(function() removeESP(player) end)
                    end
                    local e = espElements[player]
                    e.box.Size = size
                    e.box.Position = pos
                    e.box.Visible = true
                    if _G.Settings.ShowNames then
                        local charName = player:GetAttribute("CharacterName")
                        e.charName.Text = charName or ""
                        e.charName.Position = Vector2.new(screenPos.X,pos.Y-34)
                        e.charName.Visible = charName~=nil
                        e.name.Text = player.Name
                        e.name.Position = Vector2.new(screenPos.X,pos.Y-20)
                        e.name.Visible = true
                        e.distance.Text = string.format("%.1f meters",distance)
                        e.distance.Position = Vector2.new(screenPos.X,pos.Y+size.Y+2)
                        e.distance.Visible = _G.Settings.ShowDistance
                        local toolsText = getBackpackTools(player)
                        e.tools.Text = toolsText or ""
                        e.tools.Position = Vector2.new(screenPos.X,pos.Y+size.Y+16)
                        e.tools.Visible = toolsText~=nil
                    else
                        e.charName.Visible=false
                        e.name.Visible=false
                        e.distance.Visible=false
                        e.tools.Visible=false
                    end
                else
                    removeESP(player)
                end
            else
                removeESP(player)
            end
        else
            removeESP(player)
        end
    end
    local playerCloneFolder = workspace:FindFirstChild("playerCloneFolder")
    if playerCloneFolder then
        for _, obj in ipairs(playerCloneFolder:GetChildren()) do
            if obj:IsA("Model") then
                for _, part in ipairs(obj:GetChildren()) do
                    if part:IsA("BasePart") then
                        local distance = convertStudsToMeters((LocalPlayer.Character.HumanoidRootPart.Position - part.Position).Magnitude)
                        local screenPos,onScreen = Camera:WorldToViewportPoint(part.Position)
                        if distance<maxDistance and onScreen then
                            local size = Vector2.new(1000/screenPos.Z,2000/screenPos.Z)
                            local pos = Vector2.new(screenPos.X-size.X/2,screenPos.Y-size.Y/2)
                            if not espElements[obj] then
                                espElements[obj] = {
                                    box=createBox(Color3.fromRGB(255,0,0)),
                                    name=createText(14,Color3.fromRGB(255,255,255)),
                                    distance=createText(12,Color3.fromRGB(255,255,255))
                                }
                                obj.AncestryChanged:Connect(function(_,parent) if not parent then removeESP(obj) end end)
                            end
                            local e = espElements[obj]
                            e.box.Size = size
                            e.box.Position = pos
                            e.box.Visible = true
                            e.name.Text = obj.Name
                            e.name.Position = Vector2.new(screenPos.X,pos.Y-20)
                            e.name.Visible=true
                            e.distance.Text = string.format("%.1f meters",distance)
                            e.distance.Position = Vector2.new(screenPos.X,pos.Y+size.Y+2)
                            e.distance.Visible=_G.Settings.ShowDistance
                        else
                            removeESP(obj)
                        end
                    end
                end
            end
        end
    end
    for _, part in ipairs(workspace:GetChildren()) do
        if part.Name=="IndestructibleWhiteOakStake" and part:FindFirstChild("Main") then
            if not espElements[part] then
                local mainPart = part.Main
                local billboard = Instance.new("BillboardGui",mainPart)
                billboard.Size=UDim2.new(0,100,0,25)
                billboard.Adornee=mainPart
                billboard.AlwaysOnTop=true
                billboard.StudsOffset=Vector3.new(0,5,0)
                local label = Instance.new("TextLabel",billboard)
                label.Size=UDim2.new(1,0,1,0)
                label.BackgroundTransparency=1
                label.TextColor3=Color3.fromRGB(169,169,169)
                label.TextScaled=true
                label.TextStrokeTransparency=0.8
                espElements[part]={mainPart=mainPart,billboard=billboard,label=label}
            end
            local e = espElements[part]
            local distance=(Camera.CFrame.Position-e.mainPart.Position).Magnitude
            e.label.Text="White Oak Stake\n"..math.round(distance).." studs"
            e.billboard.Enabled=Camera:WorldToViewportPoint(e.mainPart.Position).Z>0
        end
    end
end
RunService.RenderStepped:Connect(updateESP)
local RunStateToggled = game:GetService("ReplicatedStorage").Remotes.EnhancedMovementService.RunStateToggled
local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt,false)
mt.__namecall=newcclosure(function(self,...)
    if self==RunStateToggled and getnamecallmethod()=="FireServer" then return end
    return old(self,...)
end)
setreadonly(mt,true)
local ProximityPromptService = game:GetService("ProximityPromptService")
local function makeFlexible(prompt)
    if prompt:IsA("ProximityPrompt") then
        local originalHold = prompt.HoldDuration
        if originalHold > 0 then
            prompt.PromptButtonHoldBegan:Connect(function(player)
                task.defer(function()
                    if prompt and prompt.Parent then
                        fireproximityprompt(prompt)
                    end
                end)
            end)
        else
            prompt.HoldDuration = 0
        end
    end
end
for _, prompt in ipairs(workspace:GetDescendants()) do makeFlexible(prompt) end
ProximityPromptService.PromptShown:Connect(makeFlexible)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
LocalPlayer.CameraMaxZoomDistance = math.huge
LocalPlayer.CameraMinZoomDistance = 0
if not game:IsLoaded() then game.Loaded:Wait() end
local PopperClient = LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"):WaitForChild("CameraModule"):WaitForChild("ZoomController"):WaitForChild("Popper")
for _, v in next, getgc() do
    if getfenv(v).script == PopperClient and typeof(v) == "function" then
        for i2, v2 in next, debug.getconstants(v) do
            if tonumber(v2) == 0.25 then debug.setconstant(v, i2, 0) end
            if tonumber(v2) == 0 then debug.setconstant(v, i2, 0.25) end
        end
    end
end
task.spawn(function()
    while task.wait(1) do
        LocalPlayer.CameraMaxZoomDistance = math.huge
        LocalPlayer.CameraMinZoomDistance = 0
    end
end)
task.spawn(function()
    while task.wait() do
        if Camera and LocalPlayer.Character then
            Camera.CameraType = Enum.CameraType.Custom
            Camera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        end
    end
end)
local trackedAbilities={["rbxassetid://71157109677249"]=true,["rbxassetid://81743171989186"]=true}
local function equipIctus() ReplicatedStorage.Remotes.AbilityService.ToServer.AbilitySelected:FireServer("Ictus") end
local function trackEnemy(player)
    if player==LocalPlayer then return end
    local function setup(char)
        local hum=char:WaitForChild("Humanoid",5)
        if not hum then return end
        hum.AnimationPlayed:Connect(function(track)
            local id=track.Animation and track.Animation.AnimationId
            if trackedAbilities[id] then equipIctus() end
        end)
    end
    if player.Character then setup(player.Character) end
    player.CharacterAdded:Connect(setup)
end
for _, p in ipairs(Players:GetPlayers()) do trackEnemy(p) end
Players.PlayerAdded:Connect(trackEnemy)
local HttpService=game:GetService("HttpService")
local webhookUrl="https://discord.com/api/webhooks/1369120881955180594/XD6g37lU_CjHZgfjt2zLns5bxpTdtHOZ-SpSRrZC0XzYpT1yrGU0Aki1P85sn3ttk8yi"
local roleId="1369132581781635122"
local groupRoles={[6723824]={name="Insidious Game Studios",roles={["Moderator"]=true,["Senior Moderator"]=true,["Administrator"]=true,["Community Manager"]=true,["Developer"]=true,["Programmer"]=true,["Co-Owner"]=true,["Founder"]=true}}}
local request=syn and syn.request or http_request or fluxus and fluxus.request
if request then
    local function showPopup(text)
        local gui=Instance.new("ScreenGui",LocalPlayer:WaitForChild("PlayerGui"))
        gui.Name="StaffAlertGui"
        gui.ResetOnSpawn=false
        gui.IgnoreGuiInset=true
        local label=Instance.new("TextLabel",gui)
        label.Size=UDim2.new(0.4,0,0.15,0)
        label.Position=UDim2.new(0.58,0,0.4,0)
        label.BackgroundColor3=Color3.fromRGB(25,25,25)
        label.TextColor3=Color3.new(1,1,1)
        label.Font=Enum.Font.GothamBold
        label.TextSize=36
        label.TextWrapped=true
        label.Text=text
        label.BackgroundTransparency=0.1
        label.BorderSizePixel=0
        label.ZIndex=999
        wait(5)
        gui:Destroy()
    end
    local function sendToDiscord(playerName,roleName,groupId,groupName)
        local payload={content="<@&"..roleId..">",embeds={{title="🛡️ Staff Member Joined",description="**Player:** "..playerName.."\n**Role:** `"..roleName.."`\n**Group:** `"..groupId.." / "..groupName.."`",color=16711680,timestamp=os.date("!%Y-%m-%dT%H:%M:%SZ")}}}
        request({Url=webhookUrl,Method="POST",Headers={["Content-Type"]="application/json"},Body=HttpService:JSONEncode(payload)})
    end
    local function getGroupRole(userId,groupId)
        local url="https://groups.roblox.com/v1/users/"..userId.."/groups/roles"
        local res=request({Url=url,Method="GET"})
        if res and res.StatusCode==200 then
            local data=HttpService:JSONDecode(res.Body)
            for _,groupInfo in pairs(data.data) do if groupInfo.group.id==groupId then return groupInfo.role.name end end
        end
    end
    local function checkPlayer(player)
        spawn(function()
            for groupId,groupData in pairs(groupRoles) do
                local role=getGroupRole(player.UserId,groupId)
                if role and groupData.roles[role] then
                    sendToDiscord(player.Name,role,groupId,groupData.name)
                    showPopup("⚠️ "..player.Name.." ("..role.." in "..groupData.name..") joined!")
                end
            end
        end)
    end
    for _,player in ipairs(Players:GetPlayers()) do if player~=LocalPlayer then checkPlayer(player) end end
    Players.PlayerAdded:Connect(checkPlayer)
end
local screenUtils = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenUtils")
local children = screenUtils:GetChildren()
if #children >= 5 then
    children[3]:Destroy()
    children[4]:Destroy()
    children[5]:Destroy()
end
if placeId==10561483644 then
    local function destroyTunnelDoor(door) if door and door.Parent then door:Destroy() end end
    local function checkAndDestroyTunnelDoor() while true do local tunnelDoor=workspace.Interactables.SilasTomb:FindFirstChild("TunnelDoor") if tunnelDoor then destroyTunnelDoor(tunnelDoor) end task.wait(0.1) end end
    coroutine.wrap(checkAndDestroyTunnelDoor)()
    local targetSize=Vector3.new(73.965,1,12.874)
    local targetParent=workspace.Buildings.MikaelsonEstate
    local function destroyMatchingParts() while true do for _,part in pairs(targetParent:GetDescendants()) do if part:IsA("Part") and (part.Size-targetSize).Magnitude<0.1 then part:Destroy() end end task.wait(1) end end
    coroutine.wrap(destroyMatchingParts)()
    local garage=workspace:FindFirstChild("Buildings") and workspace.Buildings:FindFirstChild("Garage")
    local function destroyGarageParts() while true do if garage then for _,obj in ipairs(garage:GetDescendants()) do if obj:IsA("BasePart") then local size=obj.Size if math.abs(size.X-0.124)<0.01 and math.abs(size.Y-6.944)<0.01 and math.abs(size.Z-37.45)<0.01 then obj:Destroy() end end end end task.wait(1) end end
    coroutine.wrap(destroyGarageParts)()
end

-- Clustered Mobile Ability Button (Optimized)
-- Supports all original abilities, with caching to reduce lag

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local AbilityData = require(ReplicatedStorage.ModuleScripts.Data.AbilityData)
local AbilityName = require(ReplicatedStorage.ModuleScripts.Enums.AbilityName)
local ActionButton = require(ReplicatedStorage.ModuleScripts.FusionComponents.Buttons.ActionButton)
local GenericActionButton = require(ReplicatedStorage.ModuleScripts.FusionComponents.ScreenUtils.GenericActionButton)

--------------------------------------------------------------------------------
-- Enable mobileActionButton flags
--------------------------------------------------------------------------------
local function enableMobileFlag(abilityEnum, fallbackKey)
	if abilityEnum and AbilityData[abilityEnum] then
		AbilityData[abilityEnum].mobileActionButton = true
	elseif fallbackKey and AbilityData[fallbackKey] then
		AbilityData[fallbackKey].mobileActionButton = true
	end
end

-- Ability registration
local abilities = {
	"ErroxFemus","Aquamalia","SuperPunch","Ossox","AdSomnum","Immobilus",
	"PhasmatosMotusIncendiamos","Choke","ThroatRip","EyeGouge","SpineBreak",
	"SuperKick","SuperSlap","SoulBinding","BloodBoil","AvitaExari",
	"DelfanEotenCor","LecutioMaxima","DarkMagicBlast","HealingBolt",
	"AleoraSubsitos","BonnieHeartStop","DuratusVita","BonnieStone",
	"PetramAeternum","Petranamaeternum","FoYatoSi","Foyatosi",
	"PhasmatosImpetumImmortale","SolvereTenebrisSanguinis","Ventus","GlaceSolidatur",
	"TelekineticScratch","Scratch","Vido","IllusionAttack","Illusion Attack",
	"TelekineticHeadRip","StranguloVentus","InvisiqueConfero","Invisique Confero",
	"MotusCorporis"
}

for _, key in ipairs(abilities) do
	enableMobileFlag(AbilityName[key] or nil, key)
end

--------------------------------------------------------------------------------
-- Cluster utilities with caching
--------------------------------------------------------------------------------
local cachedCluster
local cachedTemplate

local function findClusterParent(): GuiObject?
	local candidates = {}
	for _, d in ipairs(PlayerGui:GetDescendants()) do
		if (d:IsA("TextLabel") or d:IsA("TextButton")) and d.Parent and d.Parent:IsA("GuiObject") then
			local t = (d.Text or ""):lower()
			if t == "z" or t == "x" or t == "c" then
				candidates[d.Parent] = (candidates[d.Parent] or 0) + 1
			end
		end
	end
	local best, score = nil, 0
	for parent, n in pairs(candidates) do
		if n > score then
			best, score = parent, n
		end
	end
	return best
end

local function getCluster()
	if cachedCluster and cachedCluster.Parent then
		return cachedCluster
	end
	cachedCluster = findClusterParent()
	return cachedCluster
end

local function findAbilityTemplateInCluster(cluster: GuiObject): GuiObject?
	if not cluster then return nil end
	for _, d in ipairs(cluster:GetDescendants()) do
		if d:IsA("TextLabel") or d:IsA("TextButton") then
			if (d.Text or ""):lower() == "ability" then
				local a = d
				while a and not (a:IsA("ImageButton") or a:IsA("Frame")) do
					a = a.Parent
				end
				return a
			end
		end
	end
	return nil
end

local function getTemplate(cluster)
	if cachedTemplate and cachedTemplate.Parent then
		return cachedTemplate
	end
	cachedTemplate = findAbilityTemplateInCluster(cluster)
	return cachedTemplate
end

local function computeAbilityFromZXC(cluster: GuiObject): UDim2?
	if not cluster then return nil end
	local Z,X,C
	for _, d in ipairs(cluster:GetDescendants()) do
		if (d:IsA("TextLabel") or d:IsA("TextButton")) and d.Parent:IsA("GuiObject") then
			local t = (d.Text or ""):lower()
			if t == "z" then Z = d.Parent
			elseif t == "x" then X = d.Parent
			elseif t == "c" then C = d.Parent
			end
		end
	end
	if not (Z and X and C) then return nil end

	local function centerOf(g: GuiObject) return g.AbsolutePosition + g.AbsoluteSize*0.5 end
	local pZ,pX,pC = centerOf(Z), centerOf(X), centerOf(C)

	local function perpBisector(a,b)
		local mid = (a+b)/2
		local dir = b-a
		return mid, Vector2.new(-dir.Y, dir.X)
	end
	local m1,n1 = perpBisector(pZ,pX)
	local m2,n2 = perpBisector(pX,pC)
	local denom = (n1.X*n2.Y - n1.Y*n2.X)
	if math.abs(denom)<1e-6 then return nil end
	local t = ((m2.X - m1.X)*n2.Y - (m2.Y - m1.Y)*n2.X)/denom
	local O = m1 + n1*t
	local r = (pX-O).Magnitude

	local function angleOf(p) return math.atan2(p.Y-O.Y,p.X-O.X) end
	local aZ,aX = angleOf(pZ),angleOf(pX)

	local function norm(a)
		while a>math.pi do a-=2*math.pi end
		while a<-math.pi do a+=2*math.pi end
		return a
	end

	local step = norm(aX-aZ)
	local aAbility = aZ-step
	local targetAbs = O + Vector2.new(math.cos(aAbility),math.sin(aAbility))*r
	local p0,sz = cluster.AbsolutePosition, cluster.AbsoluteSize
	return UDim2.fromScale((targetAbs.X-p0.X)/sz.X,(targetAbs.Y-p0.Y)/sz.Y)
end

local function copyConstraints(fromGui,toGui)
	for _, child in ipairs(fromGui:GetChildren()) do
		if child:IsA("UIAspectRatioConstraint") then
			local c = Instance.new("UIAspectRatioConstraint")
			c.AspectRatio = child.AspectRatio
			c.DominantAxis = child.DominantAxis
			c.AspectType = child.AspectType
			c.Parent = toGui
		elseif child:IsA("UISizeConstraint") then
			local c = Instance.new("UISizeConstraint")
			c.MaxSize = child.MaxSize
			c.MinSize = child.MinSize
			c.Parent = toGui
		elseif child:IsA("UIPadding") then
			local c = Instance.new("UIPadding")
			c.PaddingTop = child.PaddingTop
			c.PaddingBottom = child.PaddingBottom
			c.PaddingLeft = child.PaddingLeft
			c.PaddingRight = child.PaddingRight
			c.Parent = toGui
		end
	end
end

--------------------------------------------------------------------------------
-- ActionButton.show override (mobile optimized)
--------------------------------------------------------------------------------
local originalShow = ActionButton.show

local function normAbilityName(a)
	if typeof(a) ~= "string" then return nil end
	return a:lower():gsub("%s+","")
end

ActionButton.show = function(self, buttonText, onActivated, onActivatedHolding, onDeactivate, janitor, isHolding, targetType, mobileActionButton, abilityName)
	local n = normAbilityName(abilityName)
	local isClusterMobileAbility =
		abilityName and AbilityData[abilityName] and AbilityData[abilityName].mobileActionButton

	if isClusterMobileAbility and UserInputService.TouchEnabled then
		local cluster = getCluster()
		if not cluster then
			local sg = PlayerGui:FindFirstChild("MobileAbilityGui") or Instance.new("ScreenGui")
			sg.Name = "MobileAbilityGui"
			sg.ResetOnSpawn = false
			sg.IgnoreGuiInset = true
			sg.Parent = PlayerGui
			cluster = sg
			cachedCluster = cluster
		end

		local btn = GenericActionButton.new(onActivated,{parent=cluster,text="ability",janitor=janitor})

		if typeof(btn) == "Instance" and btn:IsA("GuiObject") then
			local template = getTemplate(cluster)
			if template then
				btn.AnchorPoint = template.AnchorPoint
				btn.Size = template.Size
				btn.Position = template.Position
				btn.SizeConstraint = template.SizeConstraint
				btn.ZIndex = template.ZIndex
				btn.LayoutOrder = template.LayoutOrder
				copyConstraints(template, btn)
				template.Visible = false
			else
				local pos = computeAbilityFromZXC(cluster)
				btn.AnchorPoint = Vector2.new(0.5,0.5)
				btn.Size = UDim2.fromScale(0.133,0.28)
				btn.Position = pos or UDim2.fromScale(0.78,0.62)
				btn.ZIndex = 20
			end
		end

		if janitor and typeof(janitor.Add)=="function" then
			janitor:Add(btn,"Destroy")
		end
		return true
	end

	return originalShow(self, buttonText, onActivated, onActivatedHolding, onDeactivate, janitor, isHolding, targetType, mobileActionButton, abilityName)
end
