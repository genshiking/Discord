local placeId = game.PlaceId
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local maxDistance = 1000
_G.Settings = _G.Settings or { ShowNames = true, ShowDistance = true }
local toolNames = {
    RedOakStake = "RedOak",
    WhiteOakStake = "WhiteOak",
    QetsiyahCure = "QetCure",
    TheCure = "Cure",
    IndestructibleWhiteOakStake = "Indestructible"
}
local function createBox(color)
    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Transparency = 1
    box.Filled = false
    box.Color = color
    return box
end
local function createText(size,color)
    local text = Drawing.new("Text")
    text.Size = size
    text.Center = true
    text.Outline = true
    text.Color = color
    text.Visible = false
    return text
end
local espElements = {}
local function isTeammate(player)
    return LocalPlayer.Team and player.Team == LocalPlayer.Team
end
local function getBackpackTools(player)
    local backpack = player:FindFirstChildOfClass("Backpack")
    if not backpack then return nil end
    local foundTools = {}
    local addedTools = {}
    for _, tool in ipairs(backpack:GetChildren()) do
        local mappedName = toolNames[tool.Name]
        if mappedName and not addedTools[mappedName] then
            addedTools[mappedName] = true
            table.insert(foundTools, mappedName)
        end
    end
    return #foundTools>0 and table.concat(foundTools,", ") or nil
end
local function convertStudsToMeters(studs)
    return studs*0.28
end
local function removeESP(obj)
    if espElements[obj] then
        local e = espElements[obj]
        for _, v in pairs(e) do
            if v and v.Remove then v:Remove() end
        end
        espElements[obj] = nil
    end
end
local function updateESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player~=LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health>0 and not isTeammate(player) then
                local distance = convertStudsToMeters((LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude)
                local screenPos,onScreen = Camera:WorldToViewportPoint(rootPart.Position)
                if distance<maxDistance and onScreen then
                    local size = Vector2.new(1000/screenPos.Z,2000/screenPos.Z)
                    local pos = Vector2.new(screenPos.X-size.X/2,screenPos.Y-size.Y/2)
                    if not espElements[player] then
                        espElements[player] = {
                            box=createBox(Color3.fromRGB(0,0,255)),
                            charName=createText(14,Color3.fromRGB(150,150,150)),
                            name=createText(14,Color3.fromRGB(255,255,255)),
                            distance=createText(12,Color3.fromRGB(255,255,255)),
                            tools=createText(12,Color3.fromRGB(150,150,150))
                        }
                        player.AncestryChanged:Connect(function(_,parent) if not parent then removeESP(player) end end)
                        humanoid.Died:Connect(function() removeESP(player) end)
                    end
                    local e = espElements[player]
                    e.box.Size = size
                    e.box.Position = pos
                    e.box.Visible = true
                    if _G.Settings.ShowNames then
                        local charName = player:GetAttribute("CharacterName")
                        e.charName.Text = charName or ""
                        e.charName.Position = Vector2.new(screenPos.X,pos.Y-34)
                        e.charName.Visible = charName~=nil
                        e.name.Text = player.Name
                        e.name.Position = Vector2.new(screenPos.X,pos.Y-20)
                        e.name.Visible = true
                        e.distance.Text = string.format("%.1f meters",distance)
                        e.distance.Position = Vector2.new(screenPos.X,pos.Y+size.Y+2)
                        e.distance.Visible = _G.Settings.ShowDistance
                        local toolsText = getBackpackTools(player)
                        e.tools.Text = toolsText or ""
                        e.tools.Position = Vector2.new(screenPos.X,pos.Y+size.Y+16)
                        e.tools.Visible = toolsText~=nil
                    else
                        e.charName.Visible=false
                        e.name.Visible=false
                        e.distance.Visible=false
                        e.tools.Visible=false
                    end
                else
                    removeESP(player)
                end
            else
                removeESP(player)
            end
        else
            removeESP(player)
        end
    end
    local playerCloneFolder = workspace:FindFirstChild("playerCloneFolder")
    if playerCloneFolder then
        for _, obj in ipairs(playerCloneFolder:GetChildren()) do
            if obj:IsA("Model") then
                for _, part in ipairs(obj:GetChildren()) do
                    if part:IsA("BasePart") then
                        local distance = convertStudsToMeters((LocalPlayer.Character.HumanoidRootPart.Position - part.Position).Magnitude)
                        local screenPos,onScreen = Camera:WorldToViewportPoint(part.Position)
                        if distance<maxDistance and onScreen then
                            local size = Vector2.new(1000/screenPos.Z,2000/screenPos.Z)
                            local pos = Vector2.new(screenPos.X-size.X/2,screenPos.Y-size.Y/2)
                            if not espElements[obj] then
                                espElements[obj] = {
                                    box=createBox(Color3.fromRGB(255,0,0)),
                                    name=createText(14,Color3.fromRGB(255,255,255)),
                                    distance=createText(12,Color3.fromRGB(255,255,255))
                                }
                                obj.AncestryChanged:Connect(function(_,parent) if not parent then removeESP(obj) end end)
                            end
                            local e = espElements[obj]
                            e.box.Size = size
                            e.box.Position = pos
                            e.box.Visible = true
                            e.name.Text = obj.Name
                            e.name.Position = Vector2.new(screenPos.X,pos.Y-20)
                            e.name.Visible=true
                            e.distance.Text = string.format("%.1f meters",distance)
                            e.distance.Position = Vector2.new(screenPos.X,pos.Y+size.Y+2)
                            e.distance.Visible=_G.Settings.ShowDistance
                        else
                            removeESP(obj)
                        end
                    end
                end
            end
        end
    end
    for _, part in ipairs(workspace:GetChildren()) do
        if part.Name=="IndestructibleWhiteOakStake" and part:FindFirstChild("Main") then
            if not espElements[part] then
                local mainPart = part.Main
                local billboard = Instance.new("BillboardGui",mainPart)
                billboard.Size=UDim2.new(0,100,0,25)
                billboard.Adornee=mainPart
                billboard.AlwaysOnTop=true
                billboard.StudsOffset=Vector3.new(0,5,0)
                local label = Instance.new("TextLabel",billboard)
                label.Size=UDim2.new(1,0,1,0)
                label.BackgroundTransparency=1
                label.TextColor3=Color3.fromRGB(169,169,169)
                label.TextScaled=true
                label.TextStrokeTransparency=0.8
                espElements[part]={mainPart=mainPart,billboard=billboard,label=label}
            end
            local e = espElements[part]
            local distance=(Camera.CFrame.Position-e.mainPart.Position).Magnitude
            e.label.Text="White Oak Stake\n"..math.round(distance).." studs"
            e.billboard.Enabled=Camera:WorldToViewportPoint(e.mainPart.Position).Z>0
        end
    end
end
RunService.RenderStepped:Connect(updateESP)
local RunStateToggled = game:GetService("ReplicatedStorage").Remotes.EnhancedMovementService.RunStateToggled
local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt,false)
mt.__namecall=newcclosure(function(self,...)
    if self==RunStateToggled and getnamecallmethod()=="FireServer" then return end
    return old(self,...)
end)
setreadonly(mt,true)
local ProximityPromptService = game:GetService("ProximityPromptService")
local function makeFlexible(prompt)
    if prompt:IsA("ProximityPrompt") then
        local originalHold = prompt.HoldDuration
        if originalHold > 0 then
            prompt.PromptButtonHoldBegan:Connect(function(player)
                task.defer(function()
                    if prompt and prompt.Parent then
                        fireproximityprompt(prompt)
                    end
                end)
            end)
        else
            prompt.HoldDuration = 0
        end
    end
end
for _, prompt in ipairs(workspace:GetDescendants()) do makeFlexible(prompt) end
ProximityPromptService.PromptShown:Connect(makeFlexible)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
LocalPlayer.CameraMaxZoomDistance = math.huge
LocalPlayer.CameraMinZoomDistance = 0
if not game:IsLoaded() then game.Loaded:Wait() end
local PopperClient = LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"):WaitForChild("CameraModule"):WaitForChild("ZoomController"):WaitForChild("Popper")
for _, v in next, getgc() do
    if getfenv(v).script == PopperClient and typeof(v) == "function" then
        for i2, v2 in next, debug.getconstants(v) do
            if tonumber(v2) == 0.25 then debug.setconstant(v, i2, 0) end
            if tonumber(v2) == 0 then debug.setconstant(v, i2, 0.25) end
        end
    end
end
task.spawn(function()
    while task.wait(1) do
        LocalPlayer.CameraMaxZoomDistance = math.huge
        LocalPlayer.CameraMinZoomDistance = 0
    end
end)
task.spawn(function()
    while task.wait() do
        if Camera and LocalPlayer.Character then
            Camera.CameraType = Enum.CameraType.Custom
            Camera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        end
    end
end)
local trackedAbilities={["rbxassetid://71157109677249"]=true,["rbxassetid://81743171989186"]=true}
local function equipIctus() ReplicatedStorage.Remotes.AbilityService.ToServer.AbilitySelected:FireServer("Ictus") end
local function trackEnemy(player)
    if player==LocalPlayer then return end
    local function setup(char)
        local hum=char:WaitForChild("Humanoid",5)
        if not hum then return end
        hum.AnimationPlayed:Connect(function(track)
            local id=track.Animation and track.Animation.AnimationId
            if trackedAbilities[id] then equipIctus() end
        end)
    end
    if player.Character then setup(player.Character) end
    player.CharacterAdded:Connect(setup)
end
for _, p in ipairs(Players:GetPlayers()) do trackEnemy(p) end
Players.PlayerAdded:Connect(trackEnemy)
local HttpService=game:GetService("HttpService")
local webhookUrl="https://discord.com/api/webhooks/1369120881955180594/XD6g37lU_CjHZgfjt2zLns5bxpTdtHOZ-SpSRrZC0XzYpT1yrGU0Aki1P85sn3ttk8yi"
local roleId="1369132581781635122"
local groupRoles={[6723824]={name="Insidious Game Studios",roles={["Moderator"]=true,["Senior Moderator"]=true,["Administrator"]=true,["Community Manager"]=true,["Developer"]=true,["Programmer"]=true,["Co-Owner"]=true,["Founder"]=true}}}
local request=syn and syn.request or http_request or fluxus and fluxus.request
if request then
    local function showPopup(text)
        local gui=Instance.new("ScreenGui",LocalPlayer:WaitForChild("PlayerGui"))
        gui.Name="StaffAlertGui"
        gui.ResetOnSpawn=false
        gui.IgnoreGuiInset=true
        local label=Instance.new("TextLabel",gui)
        label.Size=UDim2.new(0.4,0,0.15,0)
        label.Position=UDim2.new(0.58,0,0.4,0)
        label.BackgroundColor3=Color3.fromRGB(25,25,25)
        label.TextColor3=Color3.new(1,1,1)
        label.Font=Enum.Font.GothamBold
        label.TextSize=36
        label.TextWrapped=true
        label.Text=text
        label.BackgroundTransparency=0.1
        label.BorderSizePixel=0
        label.ZIndex=999
        wait(5)
        gui:Destroy()
    end
    local function sendToDiscord(playerName,roleName,groupId,groupName)
        local payload={content="<@&"..roleId..">",embeds={{title="ðŸ›¡ï¸ Staff Member Joined",description="**Player:** "..playerName.."\n**Role:** `"..roleName.."`\n**Group:** `"..groupId.." / "..groupName.."`",color=16711680,timestamp=os.date("!%Y-%m-%dT%H:%M:%SZ")}}}
        request({Url=webhookUrl,Method="POST",Headers={["Content-Type"]="application/json"},Body=HttpService:JSONEncode(payload)})
    end
    local function getGroupRole(userId,groupId)
        local url="https://groups.roblox.com/v1/users/"..userId.."/groups/roles"
        local res=request({Url=url,Method="GET"})
        if res and res.StatusCode==200 then
            local data=HttpService:JSONDecode(res.Body)
            for _,groupInfo in pairs(data.data) do if groupInfo.group.id==groupId then return groupInfo.role.name end end
        end
    end
    local function checkPlayer(player)
        spawn(function()
            for groupId,groupData in pairs(groupRoles) do
                local role=getGroupRole(player.UserId,groupId)
                if role and groupData.roles[role] then
                    sendToDiscord(player.Name,role,groupId,groupData.name)
                    showPopup("âš ï¸ "..player.Name.." ("..role.." in "..groupData.name..") joined!")
                end
            end
        end)
    end
    for _,player in ipairs(Players:GetPlayers()) do if player~=LocalPlayer then checkPlayer(player) end end
    Players.PlayerAdded:Connect(checkPlayer)
end
local screenUtils = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenUtils")
local children = screenUtils:GetChildren()
if #children >= 5 then
    children[3]:Destroy()
    children[4]:Destroy()
    children[5]:Destroy()
end
if placeId==10561483644 then
    local function destroyTunnelDoor(door) if door and door.Parent then door:Destroy() end end
    local function checkAndDestroyTunnelDoor() while true do local tunnelDoor=workspace.Interactables.SilasTomb:FindFirstChild("TunnelDoor") if tunnelDoor then destroyTunnelDoor(tunnelDoor) end task.wait(0.1) end end
    coroutine.wrap(checkAndDestroyTunnelDoor)()
    local targetSize=Vector3.new(73.965,1,12.874)
    local targetParent=workspace.Buildings.MikaelsonEstate
    local function destroyMatchingParts() while true do for _,part in pairs(targetParent:GetDescendants()) do if part:IsA("Part") and (part.Size-targetSize).Magnitude<0.1 then part:Destroy() end end task.wait(1) end end
    coroutine.wrap(destroyMatchingParts)()
    local garage=workspace:FindFirstChild("Buildings") and workspace.Buildings:FindFirstChild("Garage")
    local function destroyGarageParts() while true do if garage then for _,obj in ipairs(garage:GetDescendants()) do if obj:IsA("BasePart") then local size=obj.Size if math.abs(size.X-0.124)<0.01 and math.abs(size.Y-6.944)<0.01 and math.abs(size.Z-37.45)<0.01 then obj:Destroy() end end end end task.wait(1) end end
    coroutine.wrap(destroyGarageParts)()
end

-- Clustered Mobile Ability Button
-- Supports: ErroxFemus, Aquamalia, SuperPunch, Ossox, AdSomnum, Immobilus,
--           PhasmatosMotusIncendiamos (Incendiamos), Choke, ThroatRip, EyeGouge, SpineBreak,
--           SuperKick, SuperSlap,
--           SoulBinding, BloodBoil, AvitaExari, DelfanEotenCor, LecutioMaxima, DarkMagicBlast, HealingBolt,
--           AleoraSubsitos (Bonnie Heartstop), DuratusVita (Bonnie Stone), PetramAeternum, FoYatoSi,
--           PhasmatosImpetumImmortale, SolvereTenebrisSanguinis, Ventus, GlaceSolidatur,
--           TelekineticScratch (Scratch), Vido,
--           IllusionAttack, TelekineticHeadRip, StranguloVentus, InvisiqueConfero, MotusCorporis
--
-- - Finds the Z/X/C cluster and snaps an "ability" puck one step BEFORE Z (counter-clockwise)
-- - If an "ability" placeholder exists in the cluster, mirrors its layout exactly
-- - Falls back gracefully if the cluster/template can't be found

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local AbilityData = require(ReplicatedStorage.ModuleScripts.Data.AbilityData)
local AbilityName = require(ReplicatedStorage.ModuleScripts.Enums.AbilityName)
local ActionButton = require(ReplicatedStorage.ModuleScripts.FusionComponents.Buttons.ActionButton)
local GenericActionButton = require(ReplicatedStorage.ModuleScripts.FusionComponents.ScreenUtils.GenericActionButton)

--------------------------------------------------------------------------------
-- Enable mobileActionButton flags (supports both enum and string keyed AbilityData)
--------------------------------------------------------------------------------
local function enableMobileFlag(abilityEnum, fallbackKey)
	if abilityEnum and AbilityData[abilityEnum] then
		AbilityData[abilityEnum].mobileActionButton = true
	elseif fallbackKey and AbilityData[fallbackKey] then
		AbilityData[fallbackKey].mobileActionButton = true
	end
end

-- previous set
enableMobileFlag(AbilityName.ErroxFemus, "ErroxFemus")
enableMobileFlag(AbilityName.Aquamalia, "Aquamalia")
enableMobileFlag(AbilityName.SuperPunch, "SuperPunch")
enableMobileFlag(AbilityName.Ossox, "Ossox")
enableMobileFlag(AbilityName.AdSomnum, "AdSomnum")
enableMobileFlag(AbilityName.Immobilus, "Immobilus")
enableMobileFlag(AbilityName.PhasmatosMotusIncendiamos, "PhasmatosMotusIncendiamos")
enableMobileFlag(AbilityName.Choke, "Choke")
enableMobileFlag(AbilityName.ThroatRip, "ThroatRip")
enableMobileFlag(AbilityName.EyeGouge, "EyeGouge")
enableMobileFlag(AbilityName.SpineBreak, "SpineBreak")
enableMobileFlag(AbilityName.SuperKick, "SuperKick")
enableMobileFlag(AbilityName.SuperSlap, "SuperSlap")

-- â€œnewerâ€ abilities (phase 1)
enableMobileFlag(AbilityName.SoulBinding, "SoulBinding")
enableMobileFlag(AbilityName.BloodBoil, "BloodBoil")
enableMobileFlag(AbilityName.AvitaExari, "AvitaExari")
enableMobileFlag(AbilityName.DelfanEotenCor, "DelfanEotenCor")
enableMobileFlag(AbilityName.LecutioMaxima, "LecutioMaxima")
enableMobileFlag(AbilityName.DarkMagicBlast, "DarkMagicBlast")
enableMobileFlag(AbilityName.HealingBolt, "HealingBolt")

-- â€œnewerâ€ abilities (phase 2)
-- Bonnie Heartstop / Aleora
enableMobileFlag(AbilityName.AleoraSubsitos, "AleoraSubsitos")
enableMobileFlag(nil, "BonnieHeartStop") -- string-only fallback

-- â€œBonnie Stoneâ€
enableMobileFlag(AbilityName.DuratusVita, "DuratusVita")
enableMobileFlag(nil, "BonnieStone") -- string-only fallback

-- Petram Aeternum
enableMobileFlag(AbilityName.PetramAeternum, "PetramAeternum")
enableMobileFlag(nil, "Petranamaeternum") -- common misspelling seen in code

-- Fo Yato Si
enableMobileFlag(AbilityName.FoYatoSi, "FoYatoSi")
enableMobileFlag(nil, "Foyatosi")

-- Phasmatos Impetum Immortale
enableMobileFlag(AbilityName.PhasmatosImpetumImmortale, "PhasmatosImpetumImmortale")

-- Solvere Tenebris Sanguinis
enableMobileFlag(AbilityName.SolvereTenebrisSanguinis, "SolvereTenebrisSanguinis")

-- Ventus / Glace / Scratch / Vido
enableMobileFlag(AbilityName.Ventus, "Ventus")
enableMobileFlag(AbilityName.GlaceSolidatur, "GlaceSolidatur")
enableMobileFlag(AbilityName.TelekineticScratch, "TelekineticScratch")
enableMobileFlag(nil, "Scratch") -- shorthand
enableMobileFlag(AbilityName.Vido, "Vido")

-- Missing from your latest list:
enableMobileFlag(AbilityName.IllusionAttack, "IllusionAttack")
enableMobileFlag(nil, "Illusion Attack") -- space variant
enableMobileFlag(AbilityName.TelekineticHeadRip, "TelekineticHeadRip")
enableMobileFlag(AbilityName.StranguloVentus, "StranguloVentus")
enableMobileFlag(AbilityName.InvisiqueConfero, "InvisiqueConfero")
enableMobileFlag(nil, "Invisique Confero") -- space variant
enableMobileFlag(AbilityName.MotusCorporis, "MotusCorporis")

--------------------------------------------------------------------------------
-- Cluster utilities
--------------------------------------------------------------------------------

-- 1) Find the Z/X/C cluster parent (the frame that actually holds those pucks)
local function findClusterParent(): GuiObject?
	local candidates = {} -- parent -> count of Z/X/C found
	for _, d in ipairs(PlayerGui:GetDescendants()) do
		if (d:IsA("TextLabel") or d:IsA("TextButton")) and d.Parent and d.Parent:IsA("GuiObject") then
			local t = (d.Text or ""):lower()
			if t == "z" or t == "x" or t == "c" then
				candidates[d.Parent] = (candidates[d.Parent] or 0) + 1
			end
		end
	end
	local best, score = nil, 0
	for parent, n in pairs(candidates) do
		if n > score then
			best, score = parent, n
		end
	end
	return best -- GuiObject or nil
end

-- 2) Inside the cluster, try to find an "ability" placeholder *in that same parent*
local function findAbilityTemplateInCluster(cluster: GuiObject): GuiObject?
	if not cluster then
		return nil
	end
	for _, d in ipairs(cluster:GetDescendants()) do
		if d:IsA("TextLabel") or d:IsA("TextButton") then
			local t = (d.Text or ""):lower()
			if t == "ability" then
				local a = d
				while a and not (a:IsA("ImageButton") or a:IsA("Frame")) do
					a = a.Parent
				end
				return a
			end
		end
	end
	return nil
end

-- 3) Solve position from the arc of Z, X, C: one step BEFORE Z (counter-clockwise)
local function computeAbilityFromZXC(cluster: GuiObject): UDim2?
	if not cluster then
		return nil
	end

	local Z, X, C
	for _, d in ipairs(cluster:GetDescendants()) do
		if (d:IsA("TextLabel") or d:IsA("TextButton")) and d.Parent and d.Parent:IsA("GuiObject") then
			local t = (d.Text or ""):lower()
			if t == "z" then
				Z = d.Parent
			elseif t == "x" then
				X = d.Parent
			elseif t == "c" then
				C = d.Parent
			end
		end
	end
	if not (Z and X and C) then
		return nil
	end

	local function centerOf(g: GuiObject)
		return g.AbsolutePosition + g.AbsoluteSize * 0.5
	end
	local pZ, pX, pC = centerOf(Z), centerOf(X), centerOf(C)

	local function perpBisector(a: Vector2, b: Vector2)
		local mid = (a + b) / 2
		local dir = b - a
		return mid, Vector2.new(-dir.Y, dir.X)
	end
	local m1, n1 = perpBisector(pZ, pX)
	local m2, n2 = perpBisector(pX, pC)
	local denom = (n1.X * n2.Y - n1.Y * n2.X)
	if math.abs(denom) < 1e-6 then
		return nil
	end
	local t = ((m2.X - m1.X) * n2.Y - (m2.Y - m1.Y) * n2.X) / denom
	local O = m1 + n1 * t
	local r = (pX - O).Magnitude

	local function angleOf(p: Vector2)
		return math.atan2(p.Y - O.Y, p.X - O.X)
	end
	local aZ, aX = angleOf(pZ), angleOf(pX)

	local function norm(a: number)
		while a > math.pi do
			a -= 2 * math.pi
		end
		while a < -math.pi do
			a += 2 * math.pi
		end
		return a
	end

	local step = norm(aX - aZ)
	local aAbility = aZ - step
	local targetAbs = O + Vector2.new(math.cos(aAbility), math.sin(aAbility)) * r
	local p0, sz = cluster.AbsolutePosition, cluster.AbsoluteSize
	return UDim2.fromScale((targetAbs.X - p0.X) / sz.X, (targetAbs.Y - p0.Y) / sz.Y)
end

local function copyConstraints(fromGui: GuiObject, toGui: GuiObject)
	for _, child in ipairs(fromGui:GetChildren()) do
		if child:IsA("UIAspectRatioConstraint") then
			local c = Instance.new("UIAspectRatioConstraint")
			c.AspectRatio = child.AspectRatio
			c.DominantAxis = child.DominantAxis
			c.AspectType = child.AspectType
			c.Parent = toGui
		elseif child:IsA("UISizeConstraint") then
			local c = Instance.new("UISizeConstraint")
			c.MaxSize = child.MaxSize
			c.MinSize = child.MinSize
			c.Parent = toGui
		elseif child:IsA("UIPadding") then
			local c = Instance.new("UIPadding")
			c.PaddingTop = child.PaddingTop
			c.PaddingBottom = child.PaddingBottom
			c.PaddingLeft = child.PaddingLeft
			c.PaddingRight = child.PaddingRight
			c.Parent = toGui
		end
	end
end

--------------------------------------------------------------------------------
-- ActionButton.show override
--------------------------------------------------------------------------------

local originalShow = ActionButton.show

local function normAbilityName(a)
	if typeof(a) ~= "string" then
		return nil
	end
	return a:lower():gsub("%s+", "")
end

ActionButton.show = function(
	self,
	buttonText,
	onActivated,
	onActivatedHolding,
	onDeactivate,
	janitor,
	isHolding,
	targetType,
	mobileActionButton,
	abilityName
)
	local n = normAbilityName(abilityName)
	local isClusterMobileAbility =
		-- existing
		abilityName == AbilityName.ErroxFemus
		or abilityName == AbilityName.Aquamalia
		or abilityName == AbilityName.SuperPunch
		or abilityName == AbilityName.Ossox
		or abilityName == AbilityName.AdSomnum
		or abilityName == AbilityName.Immobilus
		or abilityName == AbilityName.PhasmatosMotusIncendiamos
		or abilityName == AbilityName.Choke
		or abilityName == AbilityName.ThroatRip
		or abilityName == AbilityName.EyeGouge
		or abilityName == AbilityName.SpineBreak
		or abilityName == AbilityName.SuperKick
		or abilityName == AbilityName.SuperSlap
		-- phase 1
		or abilityName == AbilityName.SoulBinding
		or abilityName == AbilityName.BloodBoil
		or abilityName == AbilityName.AvitaExari
		or abilityName == AbilityName.DelfanEotenCor
		or abilityName == AbilityName.LecutioMaxima
		or abilityName == AbilityName.DarkMagicBlast
		or abilityName == AbilityName.HealingBolt
		-- phase 2
		or abilityName == AbilityName.AleoraSubsitos
		or abilityName == AbilityName.DuratusVita
		or abilityName == AbilityName.PetramAeternum
		or abilityName == AbilityName.FoYatoSi
		or abilityName == AbilityName.PhasmatosImpetumImmortale
		or abilityName == AbilityName.SolvereTenebrisSanguinis
		or abilityName == AbilityName.Ventus
		or abilityName == AbilityName.GlaceSolidatur
		or abilityName == AbilityName.TelekineticScratch
		or abilityName == AbilityName.Vido
		-- newly added from your snippets
		or abilityName == AbilityName.IllusionAttack
		or abilityName == AbilityName.TelekineticHeadRip
		or abilityName == AbilityName.StranguloVentus
		or abilityName == AbilityName.InvisiqueConfero
		or abilityName == AbilityName.MotusCorporis
		-- string fallbacks / shorthands / common typos
		or n == "erroxfemus"
		or n == "aquamalia"
		or n == "superpunch"
		or n == "ossox"
		or n == "adsomnum"
		or n == "immobilus"
		or n == "phasmatosmotusincendiamos"
		or n == "incendiamos"
		or n == "choke"
		or n == "throatrip"
		or n == "thoratrip"
		or n == "eyegouge"
		or n == "spinebreak"
		or n == "superkick"
		or n == "superslap"
		or n == "soulbinding"
		or n == "bloodboil"
		or n == "avitaexari"
		or n == "delfaneotencor"
		or n == "lecutiomaxima"
		or n == "lecutiomaxim"
		or n == "darkmagicblast"
		or n == "healingbolt"
		or n == "aleorasubsitos"
		or n == "bonnieheartstop"
		or n == "duratusvita"
		or n == "bonniestone"
		or n == "petramaeternum"
		or n == "petranamaeternum"
		or n == "foyatosi"
		or n == "foyato"
		or n == "foyato_si"
		or n == "phasmatosimpetumimmortale"
		or n == "impetumimmortale"
		or n == "solveretenebrissanguinis"
		or n == "ventus"
		or n == "glacesolidatur"
		or n == "telekineticscratch"
		or n == "scratch"
		or n == "vido"
		-- NEW fallbacks
		or n == "illusionattack"
		or n == "illusionattak" -- common slip
		or n == "telekineticheadrip"
		or n == "telekentichedrip"
		or n == "stranguloventus"
		or n == "invisiqueconfero"
		or n == "invisiquecoonfero"
		or n == "motuscorporis"

	if isClusterMobileAbility and UserInputService.TouchEnabled then
		-- create within the Z/X/C cluster (or ScreenGui fallback)
		local cluster = findClusterParent()
		if not cluster then
			local sg = PlayerGui:FindFirstChild("MobileAbilityGui") or Instance.new("ScreenGui")
			sg.Name = "MobileAbilityGui"
			sg.ResetOnSpawn = false
			sg.IgnoreGuiInset = true
			sg.Parent = PlayerGui
			cluster = sg
		end

		local btn = GenericActionButton.new(onActivated, {
			parent = cluster,
			text = "ability",
			janitor = janitor,
		})

		if typeof(btn) == "Instance" and btn:IsA("GuiObject") then
			local template = findAbilityTemplateInCluster(cluster)
			if template and template:IsA("GuiObject") then
				btn.AnchorPoint = template.AnchorPoint
				btn.Size = template.Size
				btn.Position = template.Position
				btn.SizeConstraint = template.SizeConstraint
				btn.ZIndex = template.ZIndex
				btn.LayoutOrder = template.LayoutOrder
				copyConstraints(template, btn)
				template.Visible = false
			else
				local pos = computeAbilityFromZXC(cluster)
				btn.AnchorPoint = Vector2.new(0.5, 0.5)
				btn.Size = UDim2.fromScale(0.133, 0.28)
				btn.Position = pos or UDim2.fromScale(0.78, 0.62)
				btn.ZIndex = 20
			end
		end

		if janitor and typeof(janitor.Add) == "function" then
			janitor:Add(btn, "Destroy")
		end
		return true
	end

	return originalShow(
		self,
		buttonText,
		onActivated,
		onActivatedHolding,
		onDeactivate,
		janitor,
		isHolding,
		targetType,
		mobileActionButton,
		abilityName
	)
end
